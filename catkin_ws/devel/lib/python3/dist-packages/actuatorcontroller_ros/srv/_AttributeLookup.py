# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from actuatorcontroller_ros/AttributeLookupRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class AttributeLookupRequest(genpy.Message):
  _md5sum = "3d1a6edd8baa10d0a2d261942c1e73be"
  _type = "actuatorcontroller_ros/AttributeLookupRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """bool isLookup
"""
  __slots__ = ['isLookup']
  _slot_types = ['bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       isLookup

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(AttributeLookupRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.isLookup is None:
        self.isLookup = False
    else:
      self.isLookup = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.isLookup
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 1
      (self.isLookup,) = _get_struct_B().unpack(str[start:end])
      self.isLookup = bool(self.isLookup)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.isLookup
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 1
      (self.isLookup,) = _get_struct_B().unpack(str[start:end])
      self.isLookup = bool(self.isLookup)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from actuatorcontroller_ros/AttributeLookupResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class AttributeLookupResponse(genpy.Message):
  _md5sum = "fe088f0f2cd454bd581d8618af6f4147"
  _type = "actuatorcontroller_ros/AttributeLookupResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """int32 CUR_IQ_SETTING 
int32 CUR_PROPORTIONAL 
int32 CUR_INTEGRAL      
int32 CUR_ID_SETTING    
int32 CUR_MAXSPEED      
int32 ACTUAL_CURRENT    
int32 VEL_SETTING       
int32 VEL_PROPORTIONAL  
int32 VEL_INTEGRAL      
int32 VEL_OUTPUT_LIMITATION_MINIMUM  
int32 VEL_OUTPUT_LIMITATION_MAXIMUM  
int32 ACTUAL_VELOCITY 
int32 POS_SETTING  
int32 POS_PROPORTIONAL 
int32 POS_INTEGRAL 
int32 POS_DIFFERENTIAL 
int32 POS_OUTPUT_LIMITATION_MINIMUM 
int32 POS_OUTPUT_LIMITATION_MAXIMUM 
int32 POS_LIMITATION_MINIMUM 
int32 POS_LIMITATION_MAXIMUM 
int32 HOMING_POSITION 
int32 ACTUAL_POSITION 
int32 PROFILE_POS_MAX_SPEED 
int32 PROFILE_POS_ACC 
int32 PROFILE_POS_DEC 
int32 PROFILE_VEL_MAX_SPEED 
int32 PROFILE_VEL_ACC 
int32 PROFILE_VEL_DEC 
int32 POS_OFFSET 
int32 VOLTAGE 
int32 POS_LIMITATION_SWITCH 
int32 CURRENT_SCALE  
int32 VELOCITY_SCALE 
int32 FILTER_C_STATUS 
int32 FILTER_C_VALUE  
int32 FILTER_V_STATUS 
int32 FILTER_V_VALUE  
int32 FILTER_P_STATUS 
int32 FILTER_P_VALUE  
int32 LOCK_ENERGY 
int32 ACTUATOR_TEMPERATURE 
int32 INVERTER_TEMPERATURE 
int32 ACTUATOR_PROTECT_TEMPERATURE   
int32 ACTUATOR_RECOVERY_TEMPERATURE  
int32 INVERTER_PROTECT_TEMPERATURE   
int32 INVERTER_RECOVERY_TEMPERATURE  
int32 ACTUATOR_SWITCH  
int32 FIRMWARE_VERSION 
int32 ONLINE_STATUS 
int32 SN_ID    
int32 MODE_ID  
int32 ERROR_ID 
int32 CURRENT_LIMIT  
int32 VELOCITY_LIMIT 
int32 INIT_STATE  
"""
  __slots__ = ['CUR_IQ_SETTING','CUR_PROPORTIONAL','CUR_INTEGRAL','CUR_ID_SETTING','CUR_MAXSPEED','ACTUAL_CURRENT','VEL_SETTING','VEL_PROPORTIONAL','VEL_INTEGRAL','VEL_OUTPUT_LIMITATION_MINIMUM','VEL_OUTPUT_LIMITATION_MAXIMUM','ACTUAL_VELOCITY','POS_SETTING','POS_PROPORTIONAL','POS_INTEGRAL','POS_DIFFERENTIAL','POS_OUTPUT_LIMITATION_MINIMUM','POS_OUTPUT_LIMITATION_MAXIMUM','POS_LIMITATION_MINIMUM','POS_LIMITATION_MAXIMUM','HOMING_POSITION','ACTUAL_POSITION','PROFILE_POS_MAX_SPEED','PROFILE_POS_ACC','PROFILE_POS_DEC','PROFILE_VEL_MAX_SPEED','PROFILE_VEL_ACC','PROFILE_VEL_DEC','POS_OFFSET','VOLTAGE','POS_LIMITATION_SWITCH','CURRENT_SCALE','VELOCITY_SCALE','FILTER_C_STATUS','FILTER_C_VALUE','FILTER_V_STATUS','FILTER_V_VALUE','FILTER_P_STATUS','FILTER_P_VALUE','LOCK_ENERGY','ACTUATOR_TEMPERATURE','INVERTER_TEMPERATURE','ACTUATOR_PROTECT_TEMPERATURE','ACTUATOR_RECOVERY_TEMPERATURE','INVERTER_PROTECT_TEMPERATURE','INVERTER_RECOVERY_TEMPERATURE','ACTUATOR_SWITCH','FIRMWARE_VERSION','ONLINE_STATUS','SN_ID','MODE_ID','ERROR_ID','CURRENT_LIMIT','VELOCITY_LIMIT','INIT_STATE']
  _slot_types = ['int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       CUR_IQ_SETTING,CUR_PROPORTIONAL,CUR_INTEGRAL,CUR_ID_SETTING,CUR_MAXSPEED,ACTUAL_CURRENT,VEL_SETTING,VEL_PROPORTIONAL,VEL_INTEGRAL,VEL_OUTPUT_LIMITATION_MINIMUM,VEL_OUTPUT_LIMITATION_MAXIMUM,ACTUAL_VELOCITY,POS_SETTING,POS_PROPORTIONAL,POS_INTEGRAL,POS_DIFFERENTIAL,POS_OUTPUT_LIMITATION_MINIMUM,POS_OUTPUT_LIMITATION_MAXIMUM,POS_LIMITATION_MINIMUM,POS_LIMITATION_MAXIMUM,HOMING_POSITION,ACTUAL_POSITION,PROFILE_POS_MAX_SPEED,PROFILE_POS_ACC,PROFILE_POS_DEC,PROFILE_VEL_MAX_SPEED,PROFILE_VEL_ACC,PROFILE_VEL_DEC,POS_OFFSET,VOLTAGE,POS_LIMITATION_SWITCH,CURRENT_SCALE,VELOCITY_SCALE,FILTER_C_STATUS,FILTER_C_VALUE,FILTER_V_STATUS,FILTER_V_VALUE,FILTER_P_STATUS,FILTER_P_VALUE,LOCK_ENERGY,ACTUATOR_TEMPERATURE,INVERTER_TEMPERATURE,ACTUATOR_PROTECT_TEMPERATURE,ACTUATOR_RECOVERY_TEMPERATURE,INVERTER_PROTECT_TEMPERATURE,INVERTER_RECOVERY_TEMPERATURE,ACTUATOR_SWITCH,FIRMWARE_VERSION,ONLINE_STATUS,SN_ID,MODE_ID,ERROR_ID,CURRENT_LIMIT,VELOCITY_LIMIT,INIT_STATE

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(AttributeLookupResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.CUR_IQ_SETTING is None:
        self.CUR_IQ_SETTING = 0
      if self.CUR_PROPORTIONAL is None:
        self.CUR_PROPORTIONAL = 0
      if self.CUR_INTEGRAL is None:
        self.CUR_INTEGRAL = 0
      if self.CUR_ID_SETTING is None:
        self.CUR_ID_SETTING = 0
      if self.CUR_MAXSPEED is None:
        self.CUR_MAXSPEED = 0
      if self.ACTUAL_CURRENT is None:
        self.ACTUAL_CURRENT = 0
      if self.VEL_SETTING is None:
        self.VEL_SETTING = 0
      if self.VEL_PROPORTIONAL is None:
        self.VEL_PROPORTIONAL = 0
      if self.VEL_INTEGRAL is None:
        self.VEL_INTEGRAL = 0
      if self.VEL_OUTPUT_LIMITATION_MINIMUM is None:
        self.VEL_OUTPUT_LIMITATION_MINIMUM = 0
      if self.VEL_OUTPUT_LIMITATION_MAXIMUM is None:
        self.VEL_OUTPUT_LIMITATION_MAXIMUM = 0
      if self.ACTUAL_VELOCITY is None:
        self.ACTUAL_VELOCITY = 0
      if self.POS_SETTING is None:
        self.POS_SETTING = 0
      if self.POS_PROPORTIONAL is None:
        self.POS_PROPORTIONAL = 0
      if self.POS_INTEGRAL is None:
        self.POS_INTEGRAL = 0
      if self.POS_DIFFERENTIAL is None:
        self.POS_DIFFERENTIAL = 0
      if self.POS_OUTPUT_LIMITATION_MINIMUM is None:
        self.POS_OUTPUT_LIMITATION_MINIMUM = 0
      if self.POS_OUTPUT_LIMITATION_MAXIMUM is None:
        self.POS_OUTPUT_LIMITATION_MAXIMUM = 0
      if self.POS_LIMITATION_MINIMUM is None:
        self.POS_LIMITATION_MINIMUM = 0
      if self.POS_LIMITATION_MAXIMUM is None:
        self.POS_LIMITATION_MAXIMUM = 0
      if self.HOMING_POSITION is None:
        self.HOMING_POSITION = 0
      if self.ACTUAL_POSITION is None:
        self.ACTUAL_POSITION = 0
      if self.PROFILE_POS_MAX_SPEED is None:
        self.PROFILE_POS_MAX_SPEED = 0
      if self.PROFILE_POS_ACC is None:
        self.PROFILE_POS_ACC = 0
      if self.PROFILE_POS_DEC is None:
        self.PROFILE_POS_DEC = 0
      if self.PROFILE_VEL_MAX_SPEED is None:
        self.PROFILE_VEL_MAX_SPEED = 0
      if self.PROFILE_VEL_ACC is None:
        self.PROFILE_VEL_ACC = 0
      if self.PROFILE_VEL_DEC is None:
        self.PROFILE_VEL_DEC = 0
      if self.POS_OFFSET is None:
        self.POS_OFFSET = 0
      if self.VOLTAGE is None:
        self.VOLTAGE = 0
      if self.POS_LIMITATION_SWITCH is None:
        self.POS_LIMITATION_SWITCH = 0
      if self.CURRENT_SCALE is None:
        self.CURRENT_SCALE = 0
      if self.VELOCITY_SCALE is None:
        self.VELOCITY_SCALE = 0
      if self.FILTER_C_STATUS is None:
        self.FILTER_C_STATUS = 0
      if self.FILTER_C_VALUE is None:
        self.FILTER_C_VALUE = 0
      if self.FILTER_V_STATUS is None:
        self.FILTER_V_STATUS = 0
      if self.FILTER_V_VALUE is None:
        self.FILTER_V_VALUE = 0
      if self.FILTER_P_STATUS is None:
        self.FILTER_P_STATUS = 0
      if self.FILTER_P_VALUE is None:
        self.FILTER_P_VALUE = 0
      if self.LOCK_ENERGY is None:
        self.LOCK_ENERGY = 0
      if self.ACTUATOR_TEMPERATURE is None:
        self.ACTUATOR_TEMPERATURE = 0
      if self.INVERTER_TEMPERATURE is None:
        self.INVERTER_TEMPERATURE = 0
      if self.ACTUATOR_PROTECT_TEMPERATURE is None:
        self.ACTUATOR_PROTECT_TEMPERATURE = 0
      if self.ACTUATOR_RECOVERY_TEMPERATURE is None:
        self.ACTUATOR_RECOVERY_TEMPERATURE = 0
      if self.INVERTER_PROTECT_TEMPERATURE is None:
        self.INVERTER_PROTECT_TEMPERATURE = 0
      if self.INVERTER_RECOVERY_TEMPERATURE is None:
        self.INVERTER_RECOVERY_TEMPERATURE = 0
      if self.ACTUATOR_SWITCH is None:
        self.ACTUATOR_SWITCH = 0
      if self.FIRMWARE_VERSION is None:
        self.FIRMWARE_VERSION = 0
      if self.ONLINE_STATUS is None:
        self.ONLINE_STATUS = 0
      if self.SN_ID is None:
        self.SN_ID = 0
      if self.MODE_ID is None:
        self.MODE_ID = 0
      if self.ERROR_ID is None:
        self.ERROR_ID = 0
      if self.CURRENT_LIMIT is None:
        self.CURRENT_LIMIT = 0
      if self.VELOCITY_LIMIT is None:
        self.VELOCITY_LIMIT = 0
      if self.INIT_STATE is None:
        self.INIT_STATE = 0
    else:
      self.CUR_IQ_SETTING = 0
      self.CUR_PROPORTIONAL = 0
      self.CUR_INTEGRAL = 0
      self.CUR_ID_SETTING = 0
      self.CUR_MAXSPEED = 0
      self.ACTUAL_CURRENT = 0
      self.VEL_SETTING = 0
      self.VEL_PROPORTIONAL = 0
      self.VEL_INTEGRAL = 0
      self.VEL_OUTPUT_LIMITATION_MINIMUM = 0
      self.VEL_OUTPUT_LIMITATION_MAXIMUM = 0
      self.ACTUAL_VELOCITY = 0
      self.POS_SETTING = 0
      self.POS_PROPORTIONAL = 0
      self.POS_INTEGRAL = 0
      self.POS_DIFFERENTIAL = 0
      self.POS_OUTPUT_LIMITATION_MINIMUM = 0
      self.POS_OUTPUT_LIMITATION_MAXIMUM = 0
      self.POS_LIMITATION_MINIMUM = 0
      self.POS_LIMITATION_MAXIMUM = 0
      self.HOMING_POSITION = 0
      self.ACTUAL_POSITION = 0
      self.PROFILE_POS_MAX_SPEED = 0
      self.PROFILE_POS_ACC = 0
      self.PROFILE_POS_DEC = 0
      self.PROFILE_VEL_MAX_SPEED = 0
      self.PROFILE_VEL_ACC = 0
      self.PROFILE_VEL_DEC = 0
      self.POS_OFFSET = 0
      self.VOLTAGE = 0
      self.POS_LIMITATION_SWITCH = 0
      self.CURRENT_SCALE = 0
      self.VELOCITY_SCALE = 0
      self.FILTER_C_STATUS = 0
      self.FILTER_C_VALUE = 0
      self.FILTER_V_STATUS = 0
      self.FILTER_V_VALUE = 0
      self.FILTER_P_STATUS = 0
      self.FILTER_P_VALUE = 0
      self.LOCK_ENERGY = 0
      self.ACTUATOR_TEMPERATURE = 0
      self.INVERTER_TEMPERATURE = 0
      self.ACTUATOR_PROTECT_TEMPERATURE = 0
      self.ACTUATOR_RECOVERY_TEMPERATURE = 0
      self.INVERTER_PROTECT_TEMPERATURE = 0
      self.INVERTER_RECOVERY_TEMPERATURE = 0
      self.ACTUATOR_SWITCH = 0
      self.FIRMWARE_VERSION = 0
      self.ONLINE_STATUS = 0
      self.SN_ID = 0
      self.MODE_ID = 0
      self.ERROR_ID = 0
      self.CURRENT_LIMIT = 0
      self.VELOCITY_LIMIT = 0
      self.INIT_STATE = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_55i().pack(_x.CUR_IQ_SETTING, _x.CUR_PROPORTIONAL, _x.CUR_INTEGRAL, _x.CUR_ID_SETTING, _x.CUR_MAXSPEED, _x.ACTUAL_CURRENT, _x.VEL_SETTING, _x.VEL_PROPORTIONAL, _x.VEL_INTEGRAL, _x.VEL_OUTPUT_LIMITATION_MINIMUM, _x.VEL_OUTPUT_LIMITATION_MAXIMUM, _x.ACTUAL_VELOCITY, _x.POS_SETTING, _x.POS_PROPORTIONAL, _x.POS_INTEGRAL, _x.POS_DIFFERENTIAL, _x.POS_OUTPUT_LIMITATION_MINIMUM, _x.POS_OUTPUT_LIMITATION_MAXIMUM, _x.POS_LIMITATION_MINIMUM, _x.POS_LIMITATION_MAXIMUM, _x.HOMING_POSITION, _x.ACTUAL_POSITION, _x.PROFILE_POS_MAX_SPEED, _x.PROFILE_POS_ACC, _x.PROFILE_POS_DEC, _x.PROFILE_VEL_MAX_SPEED, _x.PROFILE_VEL_ACC, _x.PROFILE_VEL_DEC, _x.POS_OFFSET, _x.VOLTAGE, _x.POS_LIMITATION_SWITCH, _x.CURRENT_SCALE, _x.VELOCITY_SCALE, _x.FILTER_C_STATUS, _x.FILTER_C_VALUE, _x.FILTER_V_STATUS, _x.FILTER_V_VALUE, _x.FILTER_P_STATUS, _x.FILTER_P_VALUE, _x.LOCK_ENERGY, _x.ACTUATOR_TEMPERATURE, _x.INVERTER_TEMPERATURE, _x.ACTUATOR_PROTECT_TEMPERATURE, _x.ACTUATOR_RECOVERY_TEMPERATURE, _x.INVERTER_PROTECT_TEMPERATURE, _x.INVERTER_RECOVERY_TEMPERATURE, _x.ACTUATOR_SWITCH, _x.FIRMWARE_VERSION, _x.ONLINE_STATUS, _x.SN_ID, _x.MODE_ID, _x.ERROR_ID, _x.CURRENT_LIMIT, _x.VELOCITY_LIMIT, _x.INIT_STATE))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 220
      (_x.CUR_IQ_SETTING, _x.CUR_PROPORTIONAL, _x.CUR_INTEGRAL, _x.CUR_ID_SETTING, _x.CUR_MAXSPEED, _x.ACTUAL_CURRENT, _x.VEL_SETTING, _x.VEL_PROPORTIONAL, _x.VEL_INTEGRAL, _x.VEL_OUTPUT_LIMITATION_MINIMUM, _x.VEL_OUTPUT_LIMITATION_MAXIMUM, _x.ACTUAL_VELOCITY, _x.POS_SETTING, _x.POS_PROPORTIONAL, _x.POS_INTEGRAL, _x.POS_DIFFERENTIAL, _x.POS_OUTPUT_LIMITATION_MINIMUM, _x.POS_OUTPUT_LIMITATION_MAXIMUM, _x.POS_LIMITATION_MINIMUM, _x.POS_LIMITATION_MAXIMUM, _x.HOMING_POSITION, _x.ACTUAL_POSITION, _x.PROFILE_POS_MAX_SPEED, _x.PROFILE_POS_ACC, _x.PROFILE_POS_DEC, _x.PROFILE_VEL_MAX_SPEED, _x.PROFILE_VEL_ACC, _x.PROFILE_VEL_DEC, _x.POS_OFFSET, _x.VOLTAGE, _x.POS_LIMITATION_SWITCH, _x.CURRENT_SCALE, _x.VELOCITY_SCALE, _x.FILTER_C_STATUS, _x.FILTER_C_VALUE, _x.FILTER_V_STATUS, _x.FILTER_V_VALUE, _x.FILTER_P_STATUS, _x.FILTER_P_VALUE, _x.LOCK_ENERGY, _x.ACTUATOR_TEMPERATURE, _x.INVERTER_TEMPERATURE, _x.ACTUATOR_PROTECT_TEMPERATURE, _x.ACTUATOR_RECOVERY_TEMPERATURE, _x.INVERTER_PROTECT_TEMPERATURE, _x.INVERTER_RECOVERY_TEMPERATURE, _x.ACTUATOR_SWITCH, _x.FIRMWARE_VERSION, _x.ONLINE_STATUS, _x.SN_ID, _x.MODE_ID, _x.ERROR_ID, _x.CURRENT_LIMIT, _x.VELOCITY_LIMIT, _x.INIT_STATE,) = _get_struct_55i().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_55i().pack(_x.CUR_IQ_SETTING, _x.CUR_PROPORTIONAL, _x.CUR_INTEGRAL, _x.CUR_ID_SETTING, _x.CUR_MAXSPEED, _x.ACTUAL_CURRENT, _x.VEL_SETTING, _x.VEL_PROPORTIONAL, _x.VEL_INTEGRAL, _x.VEL_OUTPUT_LIMITATION_MINIMUM, _x.VEL_OUTPUT_LIMITATION_MAXIMUM, _x.ACTUAL_VELOCITY, _x.POS_SETTING, _x.POS_PROPORTIONAL, _x.POS_INTEGRAL, _x.POS_DIFFERENTIAL, _x.POS_OUTPUT_LIMITATION_MINIMUM, _x.POS_OUTPUT_LIMITATION_MAXIMUM, _x.POS_LIMITATION_MINIMUM, _x.POS_LIMITATION_MAXIMUM, _x.HOMING_POSITION, _x.ACTUAL_POSITION, _x.PROFILE_POS_MAX_SPEED, _x.PROFILE_POS_ACC, _x.PROFILE_POS_DEC, _x.PROFILE_VEL_MAX_SPEED, _x.PROFILE_VEL_ACC, _x.PROFILE_VEL_DEC, _x.POS_OFFSET, _x.VOLTAGE, _x.POS_LIMITATION_SWITCH, _x.CURRENT_SCALE, _x.VELOCITY_SCALE, _x.FILTER_C_STATUS, _x.FILTER_C_VALUE, _x.FILTER_V_STATUS, _x.FILTER_V_VALUE, _x.FILTER_P_STATUS, _x.FILTER_P_VALUE, _x.LOCK_ENERGY, _x.ACTUATOR_TEMPERATURE, _x.INVERTER_TEMPERATURE, _x.ACTUATOR_PROTECT_TEMPERATURE, _x.ACTUATOR_RECOVERY_TEMPERATURE, _x.INVERTER_PROTECT_TEMPERATURE, _x.INVERTER_RECOVERY_TEMPERATURE, _x.ACTUATOR_SWITCH, _x.FIRMWARE_VERSION, _x.ONLINE_STATUS, _x.SN_ID, _x.MODE_ID, _x.ERROR_ID, _x.CURRENT_LIMIT, _x.VELOCITY_LIMIT, _x.INIT_STATE))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 220
      (_x.CUR_IQ_SETTING, _x.CUR_PROPORTIONAL, _x.CUR_INTEGRAL, _x.CUR_ID_SETTING, _x.CUR_MAXSPEED, _x.ACTUAL_CURRENT, _x.VEL_SETTING, _x.VEL_PROPORTIONAL, _x.VEL_INTEGRAL, _x.VEL_OUTPUT_LIMITATION_MINIMUM, _x.VEL_OUTPUT_LIMITATION_MAXIMUM, _x.ACTUAL_VELOCITY, _x.POS_SETTING, _x.POS_PROPORTIONAL, _x.POS_INTEGRAL, _x.POS_DIFFERENTIAL, _x.POS_OUTPUT_LIMITATION_MINIMUM, _x.POS_OUTPUT_LIMITATION_MAXIMUM, _x.POS_LIMITATION_MINIMUM, _x.POS_LIMITATION_MAXIMUM, _x.HOMING_POSITION, _x.ACTUAL_POSITION, _x.PROFILE_POS_MAX_SPEED, _x.PROFILE_POS_ACC, _x.PROFILE_POS_DEC, _x.PROFILE_VEL_MAX_SPEED, _x.PROFILE_VEL_ACC, _x.PROFILE_VEL_DEC, _x.POS_OFFSET, _x.VOLTAGE, _x.POS_LIMITATION_SWITCH, _x.CURRENT_SCALE, _x.VELOCITY_SCALE, _x.FILTER_C_STATUS, _x.FILTER_C_VALUE, _x.FILTER_V_STATUS, _x.FILTER_V_VALUE, _x.FILTER_P_STATUS, _x.FILTER_P_VALUE, _x.LOCK_ENERGY, _x.ACTUATOR_TEMPERATURE, _x.INVERTER_TEMPERATURE, _x.ACTUATOR_PROTECT_TEMPERATURE, _x.ACTUATOR_RECOVERY_TEMPERATURE, _x.INVERTER_PROTECT_TEMPERATURE, _x.INVERTER_RECOVERY_TEMPERATURE, _x.ACTUATOR_SWITCH, _x.FIRMWARE_VERSION, _x.ONLINE_STATUS, _x.SN_ID, _x.MODE_ID, _x.ERROR_ID, _x.CURRENT_LIMIT, _x.VELOCITY_LIMIT, _x.INIT_STATE,) = _get_struct_55i().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_55i = None
def _get_struct_55i():
    global _struct_55i
    if _struct_55i is None:
        _struct_55i = struct.Struct("<55i")
    return _struct_55i
class AttributeLookup(object):
  _type          = 'actuatorcontroller_ros/AttributeLookup'
  _md5sum = 'b305ca97b07bb254bb42e700d6815d17'
  _request_class  = AttributeLookupRequest
  _response_class = AttributeLookupResponse
