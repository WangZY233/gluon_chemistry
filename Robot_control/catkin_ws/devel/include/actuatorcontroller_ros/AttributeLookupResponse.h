// Generated by gencpp from file actuatorcontroller_ros/AttributeLookupResponse.msg
// DO NOT EDIT!


#ifndef ACTUATORCONTROLLER_ROS_MESSAGE_ATTRIBUTELOOKUPRESPONSE_H
#define ACTUATORCONTROLLER_ROS_MESSAGE_ATTRIBUTELOOKUPRESPONSE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace actuatorcontroller_ros
{
template <class ContainerAllocator>
struct AttributeLookupResponse_
{
  typedef AttributeLookupResponse_<ContainerAllocator> Type;

  AttributeLookupResponse_()
    : CUR_IQ_SETTING(0)
    , CUR_PROPORTIONAL(0)
    , CUR_INTEGRAL(0)
    , CUR_ID_SETTING(0)
    , CUR_MAXSPEED(0)
    , ACTUAL_CURRENT(0)
    , VEL_SETTING(0)
    , VEL_PROPORTIONAL(0)
    , VEL_INTEGRAL(0)
    , VEL_OUTPUT_LIMITATION_MINIMUM(0)
    , VEL_OUTPUT_LIMITATION_MAXIMUM(0)
    , ACTUAL_VELOCITY(0)
    , POS_SETTING(0)
    , POS_PROPORTIONAL(0)
    , POS_INTEGRAL(0)
    , POS_DIFFERENTIAL(0)
    , POS_OUTPUT_LIMITATION_MINIMUM(0)
    , POS_OUTPUT_LIMITATION_MAXIMUM(0)
    , POS_LIMITATION_MINIMUM(0)
    , POS_LIMITATION_MAXIMUM(0)
    , HOMING_POSITION(0)
    , ACTUAL_POSITION(0)
    , PROFILE_POS_MAX_SPEED(0)
    , PROFILE_POS_ACC(0)
    , PROFILE_POS_DEC(0)
    , PROFILE_VEL_MAX_SPEED(0)
    , PROFILE_VEL_ACC(0)
    , PROFILE_VEL_DEC(0)
    , POS_OFFSET(0)
    , VOLTAGE(0)
    , POS_LIMITATION_SWITCH(0)
    , CURRENT_SCALE(0)
    , VELOCITY_SCALE(0)
    , FILTER_C_STATUS(0)
    , FILTER_C_VALUE(0)
    , FILTER_V_STATUS(0)
    , FILTER_V_VALUE(0)
    , FILTER_P_STATUS(0)
    , FILTER_P_VALUE(0)
    , LOCK_ENERGY(0)
    , ACTUATOR_TEMPERATURE(0)
    , INVERTER_TEMPERATURE(0)
    , ACTUATOR_PROTECT_TEMPERATURE(0)
    , ACTUATOR_RECOVERY_TEMPERATURE(0)
    , INVERTER_PROTECT_TEMPERATURE(0)
    , INVERTER_RECOVERY_TEMPERATURE(0)
    , ACTUATOR_SWITCH(0)
    , FIRMWARE_VERSION(0)
    , ONLINE_STATUS(0)
    , SN_ID(0)
    , MODE_ID(0)
    , ERROR_ID(0)
    , CURRENT_LIMIT(0)
    , VELOCITY_LIMIT(0)
    , INIT_STATE(0)  {
    }
  AttributeLookupResponse_(const ContainerAllocator& _alloc)
    : CUR_IQ_SETTING(0)
    , CUR_PROPORTIONAL(0)
    , CUR_INTEGRAL(0)
    , CUR_ID_SETTING(0)
    , CUR_MAXSPEED(0)
    , ACTUAL_CURRENT(0)
    , VEL_SETTING(0)
    , VEL_PROPORTIONAL(0)
    , VEL_INTEGRAL(0)
    , VEL_OUTPUT_LIMITATION_MINIMUM(0)
    , VEL_OUTPUT_LIMITATION_MAXIMUM(0)
    , ACTUAL_VELOCITY(0)
    , POS_SETTING(0)
    , POS_PROPORTIONAL(0)
    , POS_INTEGRAL(0)
    , POS_DIFFERENTIAL(0)
    , POS_OUTPUT_LIMITATION_MINIMUM(0)
    , POS_OUTPUT_LIMITATION_MAXIMUM(0)
    , POS_LIMITATION_MINIMUM(0)
    , POS_LIMITATION_MAXIMUM(0)
    , HOMING_POSITION(0)
    , ACTUAL_POSITION(0)
    , PROFILE_POS_MAX_SPEED(0)
    , PROFILE_POS_ACC(0)
    , PROFILE_POS_DEC(0)
    , PROFILE_VEL_MAX_SPEED(0)
    , PROFILE_VEL_ACC(0)
    , PROFILE_VEL_DEC(0)
    , POS_OFFSET(0)
    , VOLTAGE(0)
    , POS_LIMITATION_SWITCH(0)
    , CURRENT_SCALE(0)
    , VELOCITY_SCALE(0)
    , FILTER_C_STATUS(0)
    , FILTER_C_VALUE(0)
    , FILTER_V_STATUS(0)
    , FILTER_V_VALUE(0)
    , FILTER_P_STATUS(0)
    , FILTER_P_VALUE(0)
    , LOCK_ENERGY(0)
    , ACTUATOR_TEMPERATURE(0)
    , INVERTER_TEMPERATURE(0)
    , ACTUATOR_PROTECT_TEMPERATURE(0)
    , ACTUATOR_RECOVERY_TEMPERATURE(0)
    , INVERTER_PROTECT_TEMPERATURE(0)
    , INVERTER_RECOVERY_TEMPERATURE(0)
    , ACTUATOR_SWITCH(0)
    , FIRMWARE_VERSION(0)
    , ONLINE_STATUS(0)
    , SN_ID(0)
    , MODE_ID(0)
    , ERROR_ID(0)
    , CURRENT_LIMIT(0)
    , VELOCITY_LIMIT(0)
    , INIT_STATE(0)  {
  (void)_alloc;
    }



   typedef int32_t _CUR_IQ_SETTING_type;
  _CUR_IQ_SETTING_type CUR_IQ_SETTING;

   typedef int32_t _CUR_PROPORTIONAL_type;
  _CUR_PROPORTIONAL_type CUR_PROPORTIONAL;

   typedef int32_t _CUR_INTEGRAL_type;
  _CUR_INTEGRAL_type CUR_INTEGRAL;

   typedef int32_t _CUR_ID_SETTING_type;
  _CUR_ID_SETTING_type CUR_ID_SETTING;

   typedef int32_t _CUR_MAXSPEED_type;
  _CUR_MAXSPEED_type CUR_MAXSPEED;

   typedef int32_t _ACTUAL_CURRENT_type;
  _ACTUAL_CURRENT_type ACTUAL_CURRENT;

   typedef int32_t _VEL_SETTING_type;
  _VEL_SETTING_type VEL_SETTING;

   typedef int32_t _VEL_PROPORTIONAL_type;
  _VEL_PROPORTIONAL_type VEL_PROPORTIONAL;

   typedef int32_t _VEL_INTEGRAL_type;
  _VEL_INTEGRAL_type VEL_INTEGRAL;

   typedef int32_t _VEL_OUTPUT_LIMITATION_MINIMUM_type;
  _VEL_OUTPUT_LIMITATION_MINIMUM_type VEL_OUTPUT_LIMITATION_MINIMUM;

   typedef int32_t _VEL_OUTPUT_LIMITATION_MAXIMUM_type;
  _VEL_OUTPUT_LIMITATION_MAXIMUM_type VEL_OUTPUT_LIMITATION_MAXIMUM;

   typedef int32_t _ACTUAL_VELOCITY_type;
  _ACTUAL_VELOCITY_type ACTUAL_VELOCITY;

   typedef int32_t _POS_SETTING_type;
  _POS_SETTING_type POS_SETTING;

   typedef int32_t _POS_PROPORTIONAL_type;
  _POS_PROPORTIONAL_type POS_PROPORTIONAL;

   typedef int32_t _POS_INTEGRAL_type;
  _POS_INTEGRAL_type POS_INTEGRAL;

   typedef int32_t _POS_DIFFERENTIAL_type;
  _POS_DIFFERENTIAL_type POS_DIFFERENTIAL;

   typedef int32_t _POS_OUTPUT_LIMITATION_MINIMUM_type;
  _POS_OUTPUT_LIMITATION_MINIMUM_type POS_OUTPUT_LIMITATION_MINIMUM;

   typedef int32_t _POS_OUTPUT_LIMITATION_MAXIMUM_type;
  _POS_OUTPUT_LIMITATION_MAXIMUM_type POS_OUTPUT_LIMITATION_MAXIMUM;

   typedef int32_t _POS_LIMITATION_MINIMUM_type;
  _POS_LIMITATION_MINIMUM_type POS_LIMITATION_MINIMUM;

   typedef int32_t _POS_LIMITATION_MAXIMUM_type;
  _POS_LIMITATION_MAXIMUM_type POS_LIMITATION_MAXIMUM;

   typedef int32_t _HOMING_POSITION_type;
  _HOMING_POSITION_type HOMING_POSITION;

   typedef int32_t _ACTUAL_POSITION_type;
  _ACTUAL_POSITION_type ACTUAL_POSITION;

   typedef int32_t _PROFILE_POS_MAX_SPEED_type;
  _PROFILE_POS_MAX_SPEED_type PROFILE_POS_MAX_SPEED;

   typedef int32_t _PROFILE_POS_ACC_type;
  _PROFILE_POS_ACC_type PROFILE_POS_ACC;

   typedef int32_t _PROFILE_POS_DEC_type;
  _PROFILE_POS_DEC_type PROFILE_POS_DEC;

   typedef int32_t _PROFILE_VEL_MAX_SPEED_type;
  _PROFILE_VEL_MAX_SPEED_type PROFILE_VEL_MAX_SPEED;

   typedef int32_t _PROFILE_VEL_ACC_type;
  _PROFILE_VEL_ACC_type PROFILE_VEL_ACC;

   typedef int32_t _PROFILE_VEL_DEC_type;
  _PROFILE_VEL_DEC_type PROFILE_VEL_DEC;

   typedef int32_t _POS_OFFSET_type;
  _POS_OFFSET_type POS_OFFSET;

   typedef int32_t _VOLTAGE_type;
  _VOLTAGE_type VOLTAGE;

   typedef int32_t _POS_LIMITATION_SWITCH_type;
  _POS_LIMITATION_SWITCH_type POS_LIMITATION_SWITCH;

   typedef int32_t _CURRENT_SCALE_type;
  _CURRENT_SCALE_type CURRENT_SCALE;

   typedef int32_t _VELOCITY_SCALE_type;
  _VELOCITY_SCALE_type VELOCITY_SCALE;

   typedef int32_t _FILTER_C_STATUS_type;
  _FILTER_C_STATUS_type FILTER_C_STATUS;

   typedef int32_t _FILTER_C_VALUE_type;
  _FILTER_C_VALUE_type FILTER_C_VALUE;

   typedef int32_t _FILTER_V_STATUS_type;
  _FILTER_V_STATUS_type FILTER_V_STATUS;

   typedef int32_t _FILTER_V_VALUE_type;
  _FILTER_V_VALUE_type FILTER_V_VALUE;

   typedef int32_t _FILTER_P_STATUS_type;
  _FILTER_P_STATUS_type FILTER_P_STATUS;

   typedef int32_t _FILTER_P_VALUE_type;
  _FILTER_P_VALUE_type FILTER_P_VALUE;

   typedef int32_t _LOCK_ENERGY_type;
  _LOCK_ENERGY_type LOCK_ENERGY;

   typedef int32_t _ACTUATOR_TEMPERATURE_type;
  _ACTUATOR_TEMPERATURE_type ACTUATOR_TEMPERATURE;

   typedef int32_t _INVERTER_TEMPERATURE_type;
  _INVERTER_TEMPERATURE_type INVERTER_TEMPERATURE;

   typedef int32_t _ACTUATOR_PROTECT_TEMPERATURE_type;
  _ACTUATOR_PROTECT_TEMPERATURE_type ACTUATOR_PROTECT_TEMPERATURE;

   typedef int32_t _ACTUATOR_RECOVERY_TEMPERATURE_type;
  _ACTUATOR_RECOVERY_TEMPERATURE_type ACTUATOR_RECOVERY_TEMPERATURE;

   typedef int32_t _INVERTER_PROTECT_TEMPERATURE_type;
  _INVERTER_PROTECT_TEMPERATURE_type INVERTER_PROTECT_TEMPERATURE;

   typedef int32_t _INVERTER_RECOVERY_TEMPERATURE_type;
  _INVERTER_RECOVERY_TEMPERATURE_type INVERTER_RECOVERY_TEMPERATURE;

   typedef int32_t _ACTUATOR_SWITCH_type;
  _ACTUATOR_SWITCH_type ACTUATOR_SWITCH;

   typedef int32_t _FIRMWARE_VERSION_type;
  _FIRMWARE_VERSION_type FIRMWARE_VERSION;

   typedef int32_t _ONLINE_STATUS_type;
  _ONLINE_STATUS_type ONLINE_STATUS;

   typedef int32_t _SN_ID_type;
  _SN_ID_type SN_ID;

   typedef int32_t _MODE_ID_type;
  _MODE_ID_type MODE_ID;

   typedef int32_t _ERROR_ID_type;
  _ERROR_ID_type ERROR_ID;

   typedef int32_t _CURRENT_LIMIT_type;
  _CURRENT_LIMIT_type CURRENT_LIMIT;

   typedef int32_t _VELOCITY_LIMIT_type;
  _VELOCITY_LIMIT_type VELOCITY_LIMIT;

   typedef int32_t _INIT_STATE_type;
  _INIT_STATE_type INIT_STATE;





  typedef boost::shared_ptr< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> const> ConstPtr;

}; // struct AttributeLookupResponse_

typedef ::actuatorcontroller_ros::AttributeLookupResponse_<std::allocator<void> > AttributeLookupResponse;

typedef boost::shared_ptr< ::actuatorcontroller_ros::AttributeLookupResponse > AttributeLookupResponsePtr;
typedef boost::shared_ptr< ::actuatorcontroller_ros::AttributeLookupResponse const> AttributeLookupResponseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator1> & lhs, const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator2> & rhs)
{
  return lhs.CUR_IQ_SETTING == rhs.CUR_IQ_SETTING &&
    lhs.CUR_PROPORTIONAL == rhs.CUR_PROPORTIONAL &&
    lhs.CUR_INTEGRAL == rhs.CUR_INTEGRAL &&
    lhs.CUR_ID_SETTING == rhs.CUR_ID_SETTING &&
    lhs.CUR_MAXSPEED == rhs.CUR_MAXSPEED &&
    lhs.ACTUAL_CURRENT == rhs.ACTUAL_CURRENT &&
    lhs.VEL_SETTING == rhs.VEL_SETTING &&
    lhs.VEL_PROPORTIONAL == rhs.VEL_PROPORTIONAL &&
    lhs.VEL_INTEGRAL == rhs.VEL_INTEGRAL &&
    lhs.VEL_OUTPUT_LIMITATION_MINIMUM == rhs.VEL_OUTPUT_LIMITATION_MINIMUM &&
    lhs.VEL_OUTPUT_LIMITATION_MAXIMUM == rhs.VEL_OUTPUT_LIMITATION_MAXIMUM &&
    lhs.ACTUAL_VELOCITY == rhs.ACTUAL_VELOCITY &&
    lhs.POS_SETTING == rhs.POS_SETTING &&
    lhs.POS_PROPORTIONAL == rhs.POS_PROPORTIONAL &&
    lhs.POS_INTEGRAL == rhs.POS_INTEGRAL &&
    lhs.POS_DIFFERENTIAL == rhs.POS_DIFFERENTIAL &&
    lhs.POS_OUTPUT_LIMITATION_MINIMUM == rhs.POS_OUTPUT_LIMITATION_MINIMUM &&
    lhs.POS_OUTPUT_LIMITATION_MAXIMUM == rhs.POS_OUTPUT_LIMITATION_MAXIMUM &&
    lhs.POS_LIMITATION_MINIMUM == rhs.POS_LIMITATION_MINIMUM &&
    lhs.POS_LIMITATION_MAXIMUM == rhs.POS_LIMITATION_MAXIMUM &&
    lhs.HOMING_POSITION == rhs.HOMING_POSITION &&
    lhs.ACTUAL_POSITION == rhs.ACTUAL_POSITION &&
    lhs.PROFILE_POS_MAX_SPEED == rhs.PROFILE_POS_MAX_SPEED &&
    lhs.PROFILE_POS_ACC == rhs.PROFILE_POS_ACC &&
    lhs.PROFILE_POS_DEC == rhs.PROFILE_POS_DEC &&
    lhs.PROFILE_VEL_MAX_SPEED == rhs.PROFILE_VEL_MAX_SPEED &&
    lhs.PROFILE_VEL_ACC == rhs.PROFILE_VEL_ACC &&
    lhs.PROFILE_VEL_DEC == rhs.PROFILE_VEL_DEC &&
    lhs.POS_OFFSET == rhs.POS_OFFSET &&
    lhs.VOLTAGE == rhs.VOLTAGE &&
    lhs.POS_LIMITATION_SWITCH == rhs.POS_LIMITATION_SWITCH &&
    lhs.CURRENT_SCALE == rhs.CURRENT_SCALE &&
    lhs.VELOCITY_SCALE == rhs.VELOCITY_SCALE &&
    lhs.FILTER_C_STATUS == rhs.FILTER_C_STATUS &&
    lhs.FILTER_C_VALUE == rhs.FILTER_C_VALUE &&
    lhs.FILTER_V_STATUS == rhs.FILTER_V_STATUS &&
    lhs.FILTER_V_VALUE == rhs.FILTER_V_VALUE &&
    lhs.FILTER_P_STATUS == rhs.FILTER_P_STATUS &&
    lhs.FILTER_P_VALUE == rhs.FILTER_P_VALUE &&
    lhs.LOCK_ENERGY == rhs.LOCK_ENERGY &&
    lhs.ACTUATOR_TEMPERATURE == rhs.ACTUATOR_TEMPERATURE &&
    lhs.INVERTER_TEMPERATURE == rhs.INVERTER_TEMPERATURE &&
    lhs.ACTUATOR_PROTECT_TEMPERATURE == rhs.ACTUATOR_PROTECT_TEMPERATURE &&
    lhs.ACTUATOR_RECOVERY_TEMPERATURE == rhs.ACTUATOR_RECOVERY_TEMPERATURE &&
    lhs.INVERTER_PROTECT_TEMPERATURE == rhs.INVERTER_PROTECT_TEMPERATURE &&
    lhs.INVERTER_RECOVERY_TEMPERATURE == rhs.INVERTER_RECOVERY_TEMPERATURE &&
    lhs.ACTUATOR_SWITCH == rhs.ACTUATOR_SWITCH &&
    lhs.FIRMWARE_VERSION == rhs.FIRMWARE_VERSION &&
    lhs.ONLINE_STATUS == rhs.ONLINE_STATUS &&
    lhs.SN_ID == rhs.SN_ID &&
    lhs.MODE_ID == rhs.MODE_ID &&
    lhs.ERROR_ID == rhs.ERROR_ID &&
    lhs.CURRENT_LIMIT == rhs.CURRENT_LIMIT &&
    lhs.VELOCITY_LIMIT == rhs.VELOCITY_LIMIT &&
    lhs.INIT_STATE == rhs.INIT_STATE;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator1> & lhs, const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace actuatorcontroller_ros

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fe088f0f2cd454bd581d8618af6f4147";
  }

  static const char* value(const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfe088f0f2cd454bdULL;
  static const uint64_t static_value2 = 0x581d8618af6f4147ULL;
};

template<class ContainerAllocator>
struct DataType< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "actuatorcontroller_ros/AttributeLookupResponse";
  }

  static const char* value(const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 CUR_IQ_SETTING \n"
"int32 CUR_PROPORTIONAL \n"
"int32 CUR_INTEGRAL      \n"
"int32 CUR_ID_SETTING    \n"
"int32 CUR_MAXSPEED      \n"
"int32 ACTUAL_CURRENT    \n"
"int32 VEL_SETTING       \n"
"int32 VEL_PROPORTIONAL  \n"
"int32 VEL_INTEGRAL      \n"
"int32 VEL_OUTPUT_LIMITATION_MINIMUM  \n"
"int32 VEL_OUTPUT_LIMITATION_MAXIMUM  \n"
"int32 ACTUAL_VELOCITY \n"
"int32 POS_SETTING  \n"
"int32 POS_PROPORTIONAL \n"
"int32 POS_INTEGRAL \n"
"int32 POS_DIFFERENTIAL \n"
"int32 POS_OUTPUT_LIMITATION_MINIMUM \n"
"int32 POS_OUTPUT_LIMITATION_MAXIMUM \n"
"int32 POS_LIMITATION_MINIMUM \n"
"int32 POS_LIMITATION_MAXIMUM \n"
"int32 HOMING_POSITION \n"
"int32 ACTUAL_POSITION \n"
"int32 PROFILE_POS_MAX_SPEED \n"
"int32 PROFILE_POS_ACC \n"
"int32 PROFILE_POS_DEC \n"
"int32 PROFILE_VEL_MAX_SPEED \n"
"int32 PROFILE_VEL_ACC \n"
"int32 PROFILE_VEL_DEC \n"
"int32 POS_OFFSET \n"
"int32 VOLTAGE \n"
"int32 POS_LIMITATION_SWITCH \n"
"int32 CURRENT_SCALE  \n"
"int32 VELOCITY_SCALE \n"
"int32 FILTER_C_STATUS \n"
"int32 FILTER_C_VALUE  \n"
"int32 FILTER_V_STATUS \n"
"int32 FILTER_V_VALUE  \n"
"int32 FILTER_P_STATUS \n"
"int32 FILTER_P_VALUE  \n"
"int32 LOCK_ENERGY \n"
"int32 ACTUATOR_TEMPERATURE \n"
"int32 INVERTER_TEMPERATURE \n"
"int32 ACTUATOR_PROTECT_TEMPERATURE   \n"
"int32 ACTUATOR_RECOVERY_TEMPERATURE  \n"
"int32 INVERTER_PROTECT_TEMPERATURE   \n"
"int32 INVERTER_RECOVERY_TEMPERATURE  \n"
"int32 ACTUATOR_SWITCH  \n"
"int32 FIRMWARE_VERSION \n"
"int32 ONLINE_STATUS \n"
"int32 SN_ID    \n"
"int32 MODE_ID  \n"
"int32 ERROR_ID \n"
"int32 CURRENT_LIMIT  \n"
"int32 VELOCITY_LIMIT \n"
"int32 INIT_STATE  \n"
;
  }

  static const char* value(const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.CUR_IQ_SETTING);
      stream.next(m.CUR_PROPORTIONAL);
      stream.next(m.CUR_INTEGRAL);
      stream.next(m.CUR_ID_SETTING);
      stream.next(m.CUR_MAXSPEED);
      stream.next(m.ACTUAL_CURRENT);
      stream.next(m.VEL_SETTING);
      stream.next(m.VEL_PROPORTIONAL);
      stream.next(m.VEL_INTEGRAL);
      stream.next(m.VEL_OUTPUT_LIMITATION_MINIMUM);
      stream.next(m.VEL_OUTPUT_LIMITATION_MAXIMUM);
      stream.next(m.ACTUAL_VELOCITY);
      stream.next(m.POS_SETTING);
      stream.next(m.POS_PROPORTIONAL);
      stream.next(m.POS_INTEGRAL);
      stream.next(m.POS_DIFFERENTIAL);
      stream.next(m.POS_OUTPUT_LIMITATION_MINIMUM);
      stream.next(m.POS_OUTPUT_LIMITATION_MAXIMUM);
      stream.next(m.POS_LIMITATION_MINIMUM);
      stream.next(m.POS_LIMITATION_MAXIMUM);
      stream.next(m.HOMING_POSITION);
      stream.next(m.ACTUAL_POSITION);
      stream.next(m.PROFILE_POS_MAX_SPEED);
      stream.next(m.PROFILE_POS_ACC);
      stream.next(m.PROFILE_POS_DEC);
      stream.next(m.PROFILE_VEL_MAX_SPEED);
      stream.next(m.PROFILE_VEL_ACC);
      stream.next(m.PROFILE_VEL_DEC);
      stream.next(m.POS_OFFSET);
      stream.next(m.VOLTAGE);
      stream.next(m.POS_LIMITATION_SWITCH);
      stream.next(m.CURRENT_SCALE);
      stream.next(m.VELOCITY_SCALE);
      stream.next(m.FILTER_C_STATUS);
      stream.next(m.FILTER_C_VALUE);
      stream.next(m.FILTER_V_STATUS);
      stream.next(m.FILTER_V_VALUE);
      stream.next(m.FILTER_P_STATUS);
      stream.next(m.FILTER_P_VALUE);
      stream.next(m.LOCK_ENERGY);
      stream.next(m.ACTUATOR_TEMPERATURE);
      stream.next(m.INVERTER_TEMPERATURE);
      stream.next(m.ACTUATOR_PROTECT_TEMPERATURE);
      stream.next(m.ACTUATOR_RECOVERY_TEMPERATURE);
      stream.next(m.INVERTER_PROTECT_TEMPERATURE);
      stream.next(m.INVERTER_RECOVERY_TEMPERATURE);
      stream.next(m.ACTUATOR_SWITCH);
      stream.next(m.FIRMWARE_VERSION);
      stream.next(m.ONLINE_STATUS);
      stream.next(m.SN_ID);
      stream.next(m.MODE_ID);
      stream.next(m.ERROR_ID);
      stream.next(m.CURRENT_LIMIT);
      stream.next(m.VELOCITY_LIMIT);
      stream.next(m.INIT_STATE);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct AttributeLookupResponse_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::actuatorcontroller_ros::AttributeLookupResponse_<ContainerAllocator>& v)
  {
    s << indent << "CUR_IQ_SETTING: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CUR_IQ_SETTING);
    s << indent << "CUR_PROPORTIONAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CUR_PROPORTIONAL);
    s << indent << "CUR_INTEGRAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CUR_INTEGRAL);
    s << indent << "CUR_ID_SETTING: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CUR_ID_SETTING);
    s << indent << "CUR_MAXSPEED: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CUR_MAXSPEED);
    s << indent << "ACTUAL_CURRENT: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUAL_CURRENT);
    s << indent << "VEL_SETTING: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VEL_SETTING);
    s << indent << "VEL_PROPORTIONAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VEL_PROPORTIONAL);
    s << indent << "VEL_INTEGRAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VEL_INTEGRAL);
    s << indent << "VEL_OUTPUT_LIMITATION_MINIMUM: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VEL_OUTPUT_LIMITATION_MINIMUM);
    s << indent << "VEL_OUTPUT_LIMITATION_MAXIMUM: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VEL_OUTPUT_LIMITATION_MAXIMUM);
    s << indent << "ACTUAL_VELOCITY: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUAL_VELOCITY);
    s << indent << "POS_SETTING: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_SETTING);
    s << indent << "POS_PROPORTIONAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_PROPORTIONAL);
    s << indent << "POS_INTEGRAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_INTEGRAL);
    s << indent << "POS_DIFFERENTIAL: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_DIFFERENTIAL);
    s << indent << "POS_OUTPUT_LIMITATION_MINIMUM: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_OUTPUT_LIMITATION_MINIMUM);
    s << indent << "POS_OUTPUT_LIMITATION_MAXIMUM: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_OUTPUT_LIMITATION_MAXIMUM);
    s << indent << "POS_LIMITATION_MINIMUM: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_LIMITATION_MINIMUM);
    s << indent << "POS_LIMITATION_MAXIMUM: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_LIMITATION_MAXIMUM);
    s << indent << "HOMING_POSITION: ";
    Printer<int32_t>::stream(s, indent + "  ", v.HOMING_POSITION);
    s << indent << "ACTUAL_POSITION: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUAL_POSITION);
    s << indent << "PROFILE_POS_MAX_SPEED: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PROFILE_POS_MAX_SPEED);
    s << indent << "PROFILE_POS_ACC: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PROFILE_POS_ACC);
    s << indent << "PROFILE_POS_DEC: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PROFILE_POS_DEC);
    s << indent << "PROFILE_VEL_MAX_SPEED: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PROFILE_VEL_MAX_SPEED);
    s << indent << "PROFILE_VEL_ACC: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PROFILE_VEL_ACC);
    s << indent << "PROFILE_VEL_DEC: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PROFILE_VEL_DEC);
    s << indent << "POS_OFFSET: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_OFFSET);
    s << indent << "VOLTAGE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VOLTAGE);
    s << indent << "POS_LIMITATION_SWITCH: ";
    Printer<int32_t>::stream(s, indent + "  ", v.POS_LIMITATION_SWITCH);
    s << indent << "CURRENT_SCALE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CURRENT_SCALE);
    s << indent << "VELOCITY_SCALE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VELOCITY_SCALE);
    s << indent << "FILTER_C_STATUS: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FILTER_C_STATUS);
    s << indent << "FILTER_C_VALUE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FILTER_C_VALUE);
    s << indent << "FILTER_V_STATUS: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FILTER_V_STATUS);
    s << indent << "FILTER_V_VALUE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FILTER_V_VALUE);
    s << indent << "FILTER_P_STATUS: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FILTER_P_STATUS);
    s << indent << "FILTER_P_VALUE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FILTER_P_VALUE);
    s << indent << "LOCK_ENERGY: ";
    Printer<int32_t>::stream(s, indent + "  ", v.LOCK_ENERGY);
    s << indent << "ACTUATOR_TEMPERATURE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUATOR_TEMPERATURE);
    s << indent << "INVERTER_TEMPERATURE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.INVERTER_TEMPERATURE);
    s << indent << "ACTUATOR_PROTECT_TEMPERATURE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUATOR_PROTECT_TEMPERATURE);
    s << indent << "ACTUATOR_RECOVERY_TEMPERATURE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUATOR_RECOVERY_TEMPERATURE);
    s << indent << "INVERTER_PROTECT_TEMPERATURE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.INVERTER_PROTECT_TEMPERATURE);
    s << indent << "INVERTER_RECOVERY_TEMPERATURE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.INVERTER_RECOVERY_TEMPERATURE);
    s << indent << "ACTUATOR_SWITCH: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ACTUATOR_SWITCH);
    s << indent << "FIRMWARE_VERSION: ";
    Printer<int32_t>::stream(s, indent + "  ", v.FIRMWARE_VERSION);
    s << indent << "ONLINE_STATUS: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ONLINE_STATUS);
    s << indent << "SN_ID: ";
    Printer<int32_t>::stream(s, indent + "  ", v.SN_ID);
    s << indent << "MODE_ID: ";
    Printer<int32_t>::stream(s, indent + "  ", v.MODE_ID);
    s << indent << "ERROR_ID: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ERROR_ID);
    s << indent << "CURRENT_LIMIT: ";
    Printer<int32_t>::stream(s, indent + "  ", v.CURRENT_LIMIT);
    s << indent << "VELOCITY_LIMIT: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VELOCITY_LIMIT);
    s << indent << "INIT_STATE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.INIT_STATE);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ACTUATORCONTROLLER_ROS_MESSAGE_ATTRIBUTELOOKUPRESPONSE_H
